üìä 1. Sch√©ma d‚ÄôArchitecture R√©alis√©e

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     CLIENT      ‚îÇ
‚îÇ   (PowerShell/  ‚îÇ
‚îÇ     Postman)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ HTTP:3000
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    API Node.js  ‚îÇ
‚îÇ  (Express.js)   ‚îÇ
‚îÇ  Port: 3000     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ         ‚îÇ
    ‚îÇ √âcriture‚îÇ Lecture
    ‚ñº         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PostgreSQL 16  ‚îÇ  ‚îÇ    Redis 7      ‚îÇ
‚îÇ    Primary      ‚îÇ  ‚îÇ     Cache       ‚îÇ
‚îÇ  Port: 5432     ‚îÇ  ‚îÇ  Port: 6379     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


Services Docker d√©ploy√©s :

‚úÖ postgres : Base de donn√©es unique (sans r√©plica)

‚úÖ redis : Cache en m√©moire

‚úÖ api : Application backend Node.js

‚ö†Ô∏è haproxy : Pr√©sent mais sous-utilis√© (manque de r√©plica)

√âtat final :


Containers: 3/4 actifs
R√©plication: √âchec
Cache: Fonctionnel
Haute Disponibilit√©: Non impl√©ment√©e


üîÑ 2. Strat√©gie de Lecture/√âcriture
Flux des √©critures :

Client ‚Üí API Node.js ‚Üí PostgreSQL (direct)
                     ‚Üì
              Invalidation cache Redis
Flux des lectures :

Client ‚Üí API Node.js ‚Üí V√©rification cache Redis
                     ‚Üì (si cache MISS)
                     PostgreSQL (direct)
                     ‚Üì
              Mise en cache Redis (TTL 60s)
Code r√©el impl√©ment√© :
javascript
// √âcriture
app.post('/products', (req, res) => {
  // Direct vers PostgreSQL
  writePool.query('INSERT INTO products...');
});

// Lecture avec cache
app.get('/products/:id', async (req, res) => {
  // 1. Redis d'abord
  const cached = await redisClient.get(`product:${id}`);
  if (cached) return res.json({ source: 'cache', data: JSON.parse(cached) });
  
  // 2. Sinon PostgreSQL
  const result = await readPool.query('SELECT * FROM products WHERE id = $1', [id]);
  
  // 3. Cache pour next time
  await redisClient.setEx(`product:${id}`, 60, JSON.stringify(result.rows[0]));
});
üóÉÔ∏è 3. Strat√©gie de Cache Redis
Pattern : Cache-Aside (Lazy Loading)
Cl√©s : product:{id}

TTL : 60 secondes

Invalidation : Sur modification (PUT /products/:id)

R√©silience : Timeout 1 seconde + fallback PostgreSQL

Am√©lioration de r√©silience ajout√©e :
javascript
// Version finale avec timeout
async function safeRedisGet(key) {
  try {
    return await Promise.race([
      redisClient.get(key),
      new Promise((_, reject) => 
        setTimeout(() => reject('Timeout'), 1000)
      )
    ]);
  } catch {
    return null; // Fallback silencieux vers PostgreSQL
  }
}
Sc√©narios g√©r√©s :
Cache HIT : Donn√©es retourn√©es depuis Redis (~5ms)

Cache MISS : PostgreSQL ‚Üí Redis ‚Üí Client (~50ms)

Redis down : PostgreSQL direct (~50ms + 1s timeout)

PostgreSQL down : Service indisponible (SPOF)

üìà 4. Mesures Avant/Apr√®s Cache
Tests effectu√©s :
Sc√©nario	Temps R√©ponse	Source	Gain
Sans cache (premier appel)	40-60ms	PostgreSQL	Baseline
Avec cache (HIT)	5-10ms	Redis	5-6x plus rapide
Cache MISS	40-60ms	PostgreSQL	Identique
Redis indisponible	1040-1060ms	PostgreSQL + timeout	Plus lent mais fonctionnel
Donn√©es r√©elles :
powershell
# Premier appel (MISS)
>>> source: database, cache: available
>>> Temps: ~52ms

# Deuxi√®me appel (HIT)  
>>> source: cache, data: {...}
>>> Temps: ~7ms

# Redis arr√™t√© + fallback
>>> source: database, cache: unavailable  
>>> Temps: ~1052ms (inclut timeout 1s)
Analyse :
‚úÖ Performance : Am√©lioration 5-6x sur donn√©es fr√©quentes

‚úÖ R√©silience : Service survit √† la panne Redis

‚ö†Ô∏è Latence : Timeout de 1s perceptible quand Redis down

‚ùå Disponibilit√© : PostgreSQL reste un point de d√©faillance unique

‚ö†Ô∏è 5. Retour sur la Haute Disponibilit√©
Objectif initial vs R√©alit√© :
Objectif du TP :

PostgreSQL Primary ‚îÄ‚îÄr√©plication‚îÄ‚îÄ‚ñ∂ PostgreSQL Replica
       ‚îÇ                                   ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄHAProxy (routing)‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
R√©alit√© atteinte :

PostgreSQL Primary (seul)
       ‚îÇ
       ‚îî‚îÄ‚îÄ API (cache Redis)

Configuration r√©plication :

yaml
# Tentative √©chou√©e
db-replica:
  image: postgres:16
  command: >
    bash -c "
    pg_basebackup -h db-primary -U repl -D /data -R
    postgres -c hot_standby=on
    "
# R√©sultat : pg_is_in_recovery() retournait 'f' au lieu de 't'



Le√ßons apprises :
R√©plication ‚â† Haute Disponibilit√©
La r√©plication copie les donn√©es
La HA n√©cessite un m√©canisme de basculement automatique

